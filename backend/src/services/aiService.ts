import * as tf from '@tensorflow/tfjs-node';
import { prisma } from '../config/database';
import { AIRecommendation } from '../models/mongodb/Analytics';
import { logger } from '../utils/logger';

export class AIRecommendationService {
  private model: tf.LayersModel | null = null;

  constructor() {
    this.initializeModel();
  }

  private async initializeModel() {
    try {
      // In production, load a pre-trained model
      // For now, we'll use rule-based recommendations with ML-like scoring
      logger.info('AI Recommendation Service initialized');
    } catch (error) {
      logger.error('Failed to initialize AI model:', error);
    }
  }

  async generatePersonalizedRoadmap(input: {
    userId: string;
    preferences: any;
    budget?: number;
    duration: number;
    startLocation: string;
    userLocation?: any;
  }) {
    try {
      const { userId, preferences, budget, duration, startLocation } = input;

      // Get user's historical data for personalization
      const userHistory = await this.getUserTravelHistory(userId);
      
      // Generate destinations based on preferences and budget
      const destinations = await this.recommendDestinations({
        preferences,
        budget,
        duration,
        startLocation,
        userHistory
      });

      // Generate activities for each destination
      const activities = await this.recommendActivities(destinations, preferences);

      // Generate hotel recommendations
      const hotels = await this.recommendHotels(destinations, budget);

      // Generate transport recommendations
      const transport = await this.recommendTransport(destinations, budget);

      const roadmap = {
        title: `AI Generated ${duration}-Day Trip`,
        description: 'Personalized roadmap generated by TravelEase AI',
        destinations,
        activities,
        hotels,
        transport,
        estimatedBudget: this.calculateEstimatedBudget(destinations, hotels, transport),
        aiGenerated: true
      };

      // Log recommendation for learning
      await AIRecommendation.create({
        userId,
        type: 'roadmap',
        input,
        recommendations: [roadmap]
      });

      return roadmap;

    } catch (error) {
      logger.error('Generate roadmap error:', error);
      throw error;
    }
  }

  async recommendHotels(input: {
    location: { latitude: number; longitude: number };
    budget?: number;
    preferences?: any;
    userId: string;
  }) {
    try {
      const { location, budget, preferences, userId } = input;

      // Get hotels near the location
      const hotels = await prisma.hotel.findMany({
        where: {
          isActive: true,
          // Add geospatial query here
        },
        orderBy: [
          { rating: 'desc' },
          { pricePerNight: 'asc' }
        ],
        take: 10
      });

      // Score hotels based on user preferences and budget
      const scoredHotels = hotels.map(hotel => ({
        ...hotel,
        aiScore: this.calculateHotelScore(hotel, budget, preferences)
      })).sort((a, b) => b.aiScore - a.aiScore);

      // Log recommendation
      await AIRecommendation.create({
        userId,
        type: 'hotel',
        input,
        recommendations: scoredHotels.slice(0, 5)
      });

      return scoredHotels.slice(0, 5);

    } catch (error) {
      logger.error('Recommend hotels error:', error);
      throw error;
    }
  }

  async recommendRestaurants(input: {
    location: { latitude: number; longitude: number };
    budget?: number;
    preferences?: any;
    userId: string;
  }) {
    try {
      const { location, budget, preferences, userId } = input;

      const restaurants = await prisma.restaurant.findMany({
        where: {
          isActive: true,
          // Add geospatial query here
        },
        orderBy: [
          { rating: 'desc' }
        ],
        take: 15
      });

      // Score restaurants based on preferences
      const scoredRestaurants = restaurants.map(restaurant => ({
        ...restaurant,
        aiScore: this.calculateRestaurantScore(restaurant, budget, preferences)
      })).sort((a, b) => b.aiScore - a.aiScore);

      // Log recommendation
      await AIRecommendation.create({
        userId,
        type: 'restaurant',
        input,
        recommendations: scoredRestaurants.slice(0, 8)
      });

      return scoredRestaurants.slice(0, 8);

    } catch (error) {
      logger.error('Recommend restaurants error:', error);
      throw error;
    }
  }

  async predictCrowdLevels(destinationId: string, date: Date) {
    try {
      // Simple crowd prediction based on historical data and seasonality
      const dayOfWeek = date.getDay();
      const month = date.getMonth();
      
      // Weekend factor
      const weekendFactor = (dayOfWeek === 0 || dayOfWeek === 6) ? 1.3 : 1.0;
      
      // Seasonal factor (peak months: Dec, Jan, Apr, May)
      const peakMonths = [0, 3, 4, 11]; // Jan, Apr, May, Dec
      const seasonalFactor = peakMonths.includes(month) ? 1.4 : 1.0;
      
      // Base crowd level (can be learned from historical data)
      const baseCrowdLevel = 0.6;
      
      const predictedCrowdLevel = Math.min(1.0, baseCrowdLevel * weekendFactor * seasonalFactor);
      
      return {
        level: predictedCrowdLevel,
        category: predictedCrowdLevel > 0.8 ? 'High' : predictedCrowdLevel > 0.5 ? 'Medium' : 'Low',
        confidence: 0.75
      };

    } catch (error) {
      logger.error('Predict crowd levels error:', error);
      return { level: 0.5, category: 'Medium', confidence: 0.5 };
    }
  }

  private async getUserTravelHistory(userId: string) {
    try {
      const [roadmaps, reviews, favorites] = await Promise.all([
        prisma.roadmap.findMany({
          where: { userId },
          orderBy: { createdAt: 'desc' },
          take: 10
        }),
        prisma.review.findMany({
          where: { userId },
          orderBy: { createdAt: 'desc' },
          take: 20
        }),
        prisma.favorite.findMany({
          where: { userId },
          orderBy: { createdAt: 'desc' },
          take: 50
        })
      ]);

      return { roadmaps, reviews, favorites };
    } catch (error) {
      logger.error('Get user travel history error:', error);
      return { roadmaps: [], reviews: [], favorites: [] };
    }
  }

  private async recommendDestinations(input: any) {
    // Implement destination recommendation logic
    // This would typically involve ML models trained on user behavior
    return [
      {
        name: 'Recommended Destination 1',
        location: 'City, State',
        description: 'AI recommended based on your preferences',
        estimatedDays: 2
      }
    ];
  }

  private async recommendActivities(destinations: any[], preferences: any) {
    // Implement activity recommendation logic
    return destinations.map(dest => ({
      destination: dest.name,
      activities: [
        'Sightseeing',
        'Local cuisine tasting',
        'Cultural experiences'
      ]
    }));
  }

  private async recommendTransport(destinations: any[], budget?: number) {
    // Implement transport recommendation logic
    return destinations.map(dest => ({
      destination: dest.name,
      recommendedTransport: 'Train',
      estimatedCost: 500,
      duration: '3 hours'
    }));
  }

  private calculateHotelScore(hotel: any, budget?: number, preferences?: any): number {
    let score = hotel.rating * 20; // Base score from rating (0-100)

    // Budget factor
    if (budget) {
      const budgetRatio = budget / hotel.pricePerNight;
      if (budgetRatio >= 1) {
        score += 10; // Within budget
      } else {
        score -= (1 - budgetRatio) * 30; // Penalty for over budget
      }
    }

    // Amenities matching preferences
    if (preferences?.amenities) {
      const matchingAmenities = hotel.amenities.filter((amenity: string) =>
        preferences.amenities.includes(amenity)
      ).length;
      score += matchingAmenities * 5;
    }

    return Math.max(0, Math.min(100, score));
  }

  private calculateRestaurantScore(restaurant: any, budget?: number, preferences?: any): number {
    let score = restaurant.rating * 20;

    // Price range factor
    if (budget) {
      const priceRangeScore = {
        'BUDGET': budget >= 500 ? 10 : 5,
        'MID_RANGE': budget >= 1000 ? 10 : budget >= 500 ? 5 : -5,
        'EXPENSIVE': budget >= 2000 ? 10 : -10
      };
      score += priceRangeScore[restaurant.priceRange] || 0;
    }

    // Cuisine preferences
    if (preferences?.cuisines) {
      const matchingCuisines = restaurant.cuisine.filter((cuisine: string) =>
        preferences.cuisines.includes(cuisine)
      ).length;
      score += matchingCuisines * 8;
    }

    return Math.max(0, Math.min(100, score));
  }

  private calculateEstimatedBudget(destinations: any[], hotels: any[], transport: any[]): number {
    const hotelCost = hotels.reduce((sum, hotel) => sum + (hotel.pricePerNight || 0), 0);
    const transportCost = transport.reduce((sum, t) => sum + (t.estimatedCost || 0), 0);
    const miscCost = destinations.length * 1000; // Estimated misc expenses per destination

    return hotelCost + transportCost + miscCost;
  }
}

export default AIRecommendationService;